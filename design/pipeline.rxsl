use lib::*;
use std::stage::Vertex;

pub graphics pipeline Base3D {
  groups {
    per_object: { object: ObjectRenderMatrix },
    per_frame: { camera: Camera },
  }

  vertex shader {
    input { mesh: Standard }

    fn model_view_position() -> vec3<f32> {
      object.model_view * mesh.position
    }

    fn main() {
      Vertex::ClipPosition = camera.projection * model_view_position;
      fragment.model_view_position = -model_view_position;
      fragment.normal = object.normal * mesh.normal;
      fragment.uv = mesh.uv;
    }
  }

  fragment shader {
    input {
      model_view_position: vec3<f32>,
      normal: vec3<f32>,
      uv: vec2<f32>
    }
  }
}

pub graphics component Fog {
  groups {
    per_frame: { fog: FogData },
  }

  depend {
    view_position: vec3<f32>,
    camera_position: vec3<f32>,
  }

  output {
    color: Fragment::FragmentColor,
  }

  fn main {
    color = fog.compute()
  }
}

impl FogData dependency for Base3D{
  view_position,
  camera_position: {
     
  }
}

pub graphics pipeline BasicMaterial extend Base3D {
  extend groups {
    per_object {
      #[optional]
      color_map: Texture2D,
      #[optional]
      color_map_uv_matrix: mat3<f32>,
      #[optional]
      color: vec3<f32>,
    }
  }

  vertex shader {
    fn main {
      super();
      
    }
  }

  fragment shader {
    color() -> vec3<f32> {
      if color_map.exist! && color_map_uv_matrix.exist! {
        color_map.sample(fragment.uv)
      } else {
        color
      }
    }


  }
  
}
